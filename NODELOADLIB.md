OVERVIEW
--------

nodeloadlib is a [node.js](http://nodejs.org/) library containing building blocks to programmatically create load tests for HTTP services.  The components are:

* High-level load testing interface
* A scheduler which executes functions at a given rate
* Event-based loops
* Statistics classes
* HTTP-specific monitors
* Web-based reports

QUICKSTART
----------

To create a basic load test, include `nodeloadlib.js` and use the functions provided in main load testing interface:

    // Add to example.js:
    require('./nodeloadlib');

    runTest({
        name: "Read",
        host: 'localhost',
        port: 8080,
        numClients: 20,
        timeLimit: 600,
        successCodes: [200],
        targetRps: 200,
        requestGenerator: function(client) {
            var url = '/data/object-' + Math.floor(Math.random()*10000);
            return traceableRequest(client, 'GET', url, { 'host': 'localhost' });
        }
    });
    
This test will hit localhost:8080 with 20 concurrent connections for 10 minutes. Non-200 responses are logged to `results-{timestamp}-err.log`.  It also starts up an web server on localhost:8000 for the duration of the test which displays requests per second and latency statistics:

    $ node example.js         ## while running, browse to http://localhost:8000 to track the test
    Serving progress report on port 8000.
    Opening log files.
    ......done.

    Finishing...
    Closed log files.
    Shutdown report server.


CONFIGURATION
-------------------

There are several global variables which can be defined before including nodeloadlib to control its behavior:

* **QUIET**: set to true to disable all console output (default is false)
* **HTTP_SERVER_PORT**: set to the port to start the HTTP server on (default is 8000)
* **DISABLE_HTTP_SERVER**: set to true to not start the HTTP server (default is false)
* **TEST_CONFIG**: can be "long" or "short" which changes the test reporting interval to more appropriate settings (default is "short")


COMPONENTS
-------------------

The following sections discuss individual components in `nodeloadlib`, which can be used independently.

### Load Test Functions ###

These high-level functions are useful for quickly building up complex load tests.

**Functions:**

* `runTest(spec, callback)`: Run a single test (see **Test Definition** below) and execute callback when it completes.
* `addTest(spec)`: Add a test to be run when `startTests()` is called. Tests are run concurrently.
* `addRamp(rampSpec)`: Gradually ramp up the load generated by a test after the tests are started (see **Ramp Definition** below).
* `traceableRequest(...)`: This function should be used instead of the built-in node.js `http.Client.request()`. It allows the `nodeloadlib` to correctly gather statistics about unique URLs.

**Usage**:

A "test" represents a set of requests being issued at a fixed rate over a number of concurrent connections.  Tests are run by calling `runTest()` or calling `addTest()` followed by `startTests()`.  The parameters defining a test are detailed in the Test Definition section below.  A given test can issue requests using one of three methods:

* Specifying the HTTP method, URL path, and an optional request body.  Define the `method`, `path`, and `requestData` test properties and leave `requestGenerator` and `requestLoop` as `null`.  If `requestData` is null, nodeloadlib will automatically issue GET requests.  If it defined, it will issue PUT requests instead.
* Specify a request generator by setting `requestGenerator` to a function(http.Client) -> http.ClientRequest.  The requests returned by this function will be executed by nodeloadlib.  For example, you can GET random URLs using a requestGenerator:

        addTest({
            requestGenerator: function(client) {
                return traceableRequest(client, 'GET', '/resource-' + Math.floor(Math.random()*10000));
            }
        });

* Specify a request loop by setting the `requestLoop` to a function(loopFun, http.Client) which calls loopFun({req: http.ClientRequest, res: http.ClientResponse}) after each request is complete.  This method provides the most flexibility, but the function must be sure to call `loopFun()` or it will not be called properly.  For example, you can issue `PUT` requests with proper `If-Match` headers using a `requestLoop`:

        addTest({
            requestLoop: function(loopFun, client) {
                var req = traceableRequest(client, 'GET', '/resource');
                req.addListener('response', function(response) {
                    if (response.statusCode != 200 && response.statusCode != 404) {
                        loopFun({req: req, res: response});
                    } else {
                        var headers = { };
                        if (response.headers['etag'] != null)
                            headers['if-match'] = response.headers['etag'];
                        req = traceableRequest(client, 'PUT', '/resource', headers, "new value");
                        req.addListener('response', function(response) {
                            loopFun({req: req, res: response});
                        });
                        req.close();
                    }
                });
                req.close();
            }
        });

A "ramp" allows you to increase the load generated by a particular test after the test has started and over some period of time.  Schedule a ramp after scheduling a test using `addTest()`, by calling `addRamp()`:

    var test1 = addTest({
        targetRps: 100,
        requestGenerator: function(client) {
            return traceableRequest(client, 'GET', '/resource-' + Math.floor(Math.random()*10000));
        }
    });
    
    // Add 100 requests / second using 10 concurrent connections to test1 between minutes 1 and 2
    addRamp({
        test: test1,
        numberOfSteps: 10,
        timeLimit: 60,
        rpsPerStep: 10,
        clientsPerStep: 1,
        delay: 60
    });

Check out `examples/nodeloadlib-ex.js`, for a full example, which runs a read+write test with a ramp.

**Test Definition:** The following object defines the parameters and defaults for a test, which is used by `addTest()` or `runTest()`:

    var TEST_DEFAULTS = {
        name: 'Debug test',                 // A descriptive name for the test
        host: 'localhost',                  // host and port specify where to connect
        port: 8080,                         //
        requestGenerator: null,             // Specify one of: requestGenerator, requestLoop, or (method, path, requestData)
        requestLoop: null,                  //   - A requestGenerator is a function that takes a http.Client param
        method: 'GET',                      //     and returns a http.ClientRequest.
        path: '/',                          //   - A requestLoop is a function that takes two params (loopFun, http.Client).
        requestData: null,                  //     It should call loopFun({req: http.ClientRequest, res: http.ClientResponse})
                                            //     after each operation to schedule the next iteration of requestLoop.
                                            //   - (method, path, requestData) specify a single URL to test
        numClients: 10,                     // Maximum number of concurrent executions of request loop
        numRequests: Infinity,              // Maximum number of iterations of request loop
        timeLimit: 120,                     // Maximum duration of test in seconds
        targetRps: Infinity,                // Number of times per second to execute request loop
        delay: 0,                           // Seconds before starting test
        successCodes: null,                 // List of success HTTP response codes. Failures are logged to the error log.
        stats: ['latency', 'result-codes'], // Specify list of: latency, result-codes, uniques, concurrency. Note that "uniques"
                                            // only shows up in summary report and requests must be made with traceableRequest().
                                            // Not doing so will result in reporting only 2 uniques.
        reportInterval: 2,                  // Seconds between each progress report
    }
    
**Ramp Definition:** The following object defines the parameters and defaults for a ramp, which is used to increase the load generated by a test over time. It is used by `addRamp()`:
    
    var RAMP_DEFAULTS = {
        test: null,                         // The test to ramp up, returned from from addTest()
        numberOfSteps: 10,                  // Number of steps in ramp
        timeLimit: 10,                      // The total number of seconds to ramp up
        rpsPerStep: 10,                     // The rps to add to the test at each step
        clientsPerStep: 1,                  // The number of connections to add to the test at each step.
        delay: 0                            // Number of seconds to wait before ramping up. 
    }



### Function Scheduler ###

The `SCHEDULER` object allows a function to be called at a desired rate and concurrency level.

**Functions:**

* `SCHEDULER.schedule(spec)`: Schedule a function to the executed by the scheduler (see the **Schedule Definition** below)
* `SCHEDULER.startAll(callback)`: Start running all the scheduled functions and execute callback when they all complete
* `SCHEDULER.startSchedule(callback)`: Start a single scheduled function and execute callback when it completes
* `funLoop(fun)`: Wrap functions that do not perform IO so they can be used with SCHEDULER

**Usage**:

Call `SCHEDULER.schedule(spec)` to add a job. `spec.fun` must be a `function(loopFun, args)` and call `loopFun(results)` when it completes. Call `SCHEDULER.startAll()` to start running all scheduled jobs.

If `spec.argGenerator` is non-null, it is called `spec.concurrency` times on startup. One return value is passed as the second parameter to each concurrent execution of `spec.fun`.  If it is null, then the value of `spec.args` is passed to all executions of `spec.fun`.

A scheduled job finishes after its target duration or it has been called the maximum number of times. `SCHEDULER` stops *all* running jobs once all *monitored* jobs finish. For example, 1 monitored job is scheduled for 5 seconds, and 2 unmonitored jobs are scheduled with no time limits. `SCHEDULER` will start all 3 jobs when `SCHEDULER.startAll()` is called, and stop all 3 jobs 5 seconds later.  Unmonitored jobs are useful for running side processes such as statistics gathering and reporting.

Example:

    var t = 1;
    SCHEDULER.schedule({
        fun: funLoop(function(i) { sys.puts("Thread " + i) }),
        argGenerator: function() { return t++; },
        concurrency: 5,
        rps: 10,
        duration: 10
    });
    SCHEDULER.startAll(function() { sys.puts("Done.") });


**Job Definition**: The following object defines the parameters and defaults for a job run by `SCHEDULER`:

    var JOB_DEFAULTS = {
        fun: null,                  // A function to execute which accepts the parameters (loopFun, args).
                                    // The value of args is the return value of argGenerator() or the args
                                    // parameter if argGenerator is null. The function must call 
                                    // loopFun(results) when it completes.
        argGenerator: null,         // A function which is called once when the job is started. The return
                                    // value is passed to fun as the "args" parameter. This is useful when
                                    // concurrency > 1, and each "thread" should have its own args.
        args: null,                 // If argGenerator is NOT specified, then this is passed to the fun as "args".
        concurrency: 1,             // Number of concurrent calls of fun()
        rps: Infinity,              // Target number of time per second to call fun()
        duration: Infinity,         // Maximum duration of this job in seconds
        numberOfTimes: Infinity,    // Maximum number of times to call fun()
        delay: 0,                   // Seconds to wait before calling fun() for the first time
        monitored: true             // Does this job need to finish in order for SCHEDULER.startAll() to end?
    };


### Event-based loops ###

The `ConditionalLoop` class provides a generic way to write a loop where each iteration is scheduled using `process.nextTick()`. This allows many long running "loops" to be executed concurrently by `node.js`.

**Functions:**

* `ConditionalLoop(fun, args, conditions, delay):` Defines a loop (see **Loop Definition** below)
* `ConditionalLoop.start(callback):` Starts executing the loop and call `callback` when it terminates
* `ConditionalLoop.stop():` Terminate the loop
* `timeLimit(seconds)`, `maxExecutions(numberOfTimes)`: conditions that can be used with a ConditionalLoop
* `rpsLoop(rps, fun)`: Wrap a `function(loopFun, args)` so ConditionalLoop calls it a set rate
* `funLoop(fun)`: Wrap a non-IO performing `function(args)` so it can be used with a ConditionalLoop 

**Usage:**

Create a `ConditionalLoop` instance and call `ConditionalLoop.start()` to execute the loop. A function to be executed by `ConditionalLoop` must be a `function(loopFun, args)` which ends by calling `loopFun()`.

The `conditions` parameter is a list of functions. When any function returns `false`, the loop terminates. For example, the functions `timeLimit(seconds)` and `maxExecutions(numberOfTimes)` are conditions that limit the duration and number of iterations of a loop respectively.

The loop also terminates if `ConditionalLoop.stop()` is called.

Example:

    var fun = function(loopFun, startTime) {
        sys.puts("It's been " + (new Date() - startTime) / 1000 + " seconds");
        loopFun();
    };
    var stopOnFriday = function() {
        return (new Date()).getDay() < 5;
    }
    var loop = new ConditionalLoop(rpsLoop(1, fun), new Date(), [stopOnFriday, timeLimit(604800 /*1 week*/)], 1);
    loop.start(function() { sys.puts("It's Friday!") });

**Loop Definition:**

The `ConditionalLoop` constructor arguments are:

    fun: A function that takes parameters (loopFun, args) and calls loopFun() after each iteration
    args: The args parameter to pass to fun
    conditions: A list of functions representing termination conditions. The loop terminates
                when any function returns `false`.
    delay: Seconds to wait before starting the first iteration